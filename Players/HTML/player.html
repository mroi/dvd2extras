<!DOCTYPE html>
<meta charset="utf-8">
<title>Video Player</title>
<script>

// initialize basic styling
document.documentElement.style.height = "100%";
document.documentElement.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
document.documentElement.style.backgroundColor = "black";
document.documentElement.style.color = "white";

// check browser support for CSS min(), which is the most cutting-edge feature needed
document.documentElement.style.width = "min(2px, 1px)";
var result = getComputedStyle(document.documentElement, null).width;
document.documentElement.style.width = "";
if (result != "1px") {
	// show error message
	var translations = {
		"de": "Bitte aktualisiere Deinen Browser, er unterst√ºtzt diesen Player nicht.",
		"en": "Please update your browser, it player does not support this player."
	};
	var message = translations[navigator.language.replace(/-.*/, "")];
	if (!message) message = translations["en"];

	var error = document.createElement("div");
	error.style.textAlign = "center";
	error.style.fontSize = "120%";
	error.style.padding = "2vh 2vw";
	error.textContent = message;
	document.documentElement.appendChild(error);
}

// end the script tag to segregate the compatibility check above from unwitting syntax errors below
</script><script>
if (error) throw Error("browser incompatible");

class Player {

	constructor() {
		document.body.style.display = "grid";
		document.body.style.height = "100%";
		document.body.style.margin = "0";

		// container div
		const container = document.createElement("div");
		container.style.position = "relative";
		container.style.margin = "auto";
		document.body.append(container);

		// main video player
		const video = document.createElement("video");
		video.controls = true;
		video.style.display = "block";
		video.style.outline = "none";
		video.addEventListener("resize", event => {
			let aspect = this.video.videoWidth / this.video.videoHeight;
			if (!aspect)
				aspect = this.video.scrollWidth / this.video.scrollHeight;
			if (aspect) {
				this.video.style.width = "min(100vw, " + aspect * 100 + "vh)";
				this.video.style.height = "min(100vh, " + 1/aspect * 100 + "vw)";
			}
		});
		container.append(video);
		this.video = video;

		// menu container
		let menu = document.createElement("div");
		menu.style.width = "100%";
		menu.style.height = "100%";
		menu.style.position = "absolute";
		menu.style.top = "0";
		menu.style.fontSize = "4vmin";
		container.append(menu);
		this.menu = menu;
	}

	async loadVideo(...urls) {
		let hlsUrl;

		this.video.innerHTML = "";
		urls.forEach(url => {
			const mimeTypes = {
				"m3u8": "application/vnd.apple.mpegurl",
				"m4v": "video/mp4",
				"mp4": "video/mp4",
				"webm": "video/webm"
			};
			const extension = url.split(".").pop();
			const source = document.createElement("source");
			source.type = mimeTypes[extension];
			source.src = url;
			this.video.append(source);
			if (extension == "m3u8") hlsUrl = url;
		});

		// check for native HLS support or load JavaScript implementation
		if (hlsUrl && this.video.canPlayType("application/vnd.apple.mpegURL") != "maybe") {
			if (typeof Hls == "undefined")
				await this.loadScript("hls.js");  // https://github.com/video-dev/hls.js
			if (Hls.isSupported()) {
				const hls = new Hls();
				hls.attachMedia(this.video);
				hls.on(Hls.Events.MEDIA_ATTACHED, () => {
					hls.loadSource(hlsUrl);
				});
			}
		}
	}

	async loadScript(url) {
		// add a script tag instead of dynamic imports to circumvent same-origin restrictions
		return new Promise((resolve, reject) => {
			const script = document.createElement("script");
			script.src = url;
			script.addEventListener("load", event => {
				resolve();
			});
			script.addEventListener("error", event => {
				reject();
			});
			document.body.append(script);
		});
	}
}

document.addEventListener("DOMContentLoaded", event => {
	const player = new Player();
	// TODO: setup player from JSONP information
});
</script>
