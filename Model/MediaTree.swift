import Dispatch


/* MARK: Node Types and Properties */

/// The media tree stores the structure of menus and playable assets.
///
/// Media tree is a recursive data structure formed from nodes with associated
/// values. Some nodes contain further child nodes as payload. The goal of the
/// media tree is to formalize a simple menu structure as the common interface
/// that is created by importers and understood by exporters. Transformation
/// of the tree during import and export is performed by `Pass` instances.
public indirect enum MediaTree {

	/// A playable asset like a movie or TV show.
	case asset(AssetNode)

	/// A group of nodes presented to the user for interaction.
	case menu(MenuNode)

	/// A reference to another node in the tree.
	case link(LinkNode)

	/// A collection of media trees.
	case collection(CollectionNode)

	/// An intermediate states during transformations.
	case opaque(OpaqueNode)
}

extension MediaTree {

	/// Node type for a playable asset like a movie or TV show.
	public struct AssetNode: Identifiable {
		public let id: ID

		public var kind: Kind
		public var content: MediaRecipe
		public var successor: MediaTree?

		public init(kind: Kind, content: MediaRecipe, successor: MediaTree? = nil) {
			self.id = ID()
			self.kind = kind
			self.content = content
			self.successor = successor
		}

		/// The kind of playable asset represented by an `AssetNode`.
		public enum Kind {
			/// A feature film or short film.
			case movie
			/// An individual show of episodic content, typically a TV show.
			case episode
			/// Accompanying material like bonus content.
			case extra
		}
	}

	/// Node type for a group of nodes presented to the user for interaction.
	public struct MenuNode: Identifiable {
		public let id: ID

		public var children: [MediaTree]
		public var background: MediaRecipe

		public init(children: [MediaTree], background: MediaRecipe) {
			self.id = ID()
			self.children = children
			self.background = background
		}
	}

	/// Node type for a reference to another node in the tree.
	public struct LinkNode {
		public var target: ID
		public init(target: ID) {
			self.target = target
		}
	}

	/// Node type for a collection of media trees.
	public struct CollectionNode {
		public var children: [MediaTree]
		public init(children: [MediaTree]) {
			self.children = children
		}
	}

	/// Node type for an intermediate states during transformations.
	public struct OpaqueNode: Identifiable {
		public let id: ID

		public var payload: Any
		public var children: [MediaTree]

		public init(payload: Any, children: [MediaTree] = []) {
			self.id = ID()
			self.payload = payload
			self.children = children
		}
	}
}

extension MediaTree {

	/// Identifier for media tree nodes.
	///
	/// A new ID value is generated by atomically incrementing a counter.
	public struct ID: Equatable, Hashable {
		private let value: Int

		// TODO: change to @TaskLocal allocator
		static var allocator = Allocator()

		fileprivate init() { value = Self.allocator.next() }

		class Allocator {
			private var counter = 0
			private let lock = DispatchSemaphore(value: 1)
			fileprivate func next() -> Int {
				lock.wait()
				defer { lock.signal() }
				defer { counter += 1 }
				return counter
			}
		}
	}
}


/* MARK: Media Data Handling */

/// All information needed to create a new representation of the media asset.
public struct MediaRecipe {
	// TODO: add common properties and customization points
	// * data source
	// * video, language, and subtitle track configuration
	// * metadata dictionary [enum: String]
}

/// Obtains data for a single asset from its source.
public protocol MediaDataSource {
	// TODO: functionality to fetch data from source media
}


/* MARK: Convenience Accessors */

extension MediaTree {

	/// Convenience accessor for asset nodes.
	public var asset: AssetNode? {
		if case .asset(let node) = self { return node } else { return nil }
	}
	/// Convenience accessor for menu nodes.
	public var menu: MenuNode? {
		if case .menu(let node) = self { return node } else { return nil }
	}
	/// Convenience accessor for link nodes.
	public var link: LinkNode? {
		if case .link(let node) = self { return node } else { return nil }
	}
	/// Convenience accessor for collection nodes.
	public var collection: CollectionNode? {
		if case .collection(let node) = self { return node } else { return nil }
	}
	/// Convenience accessor for opaque nodes.
	public var opaque: OpaqueNode? {
		if case .opaque(let node) = self { return node } else { return nil }
	}

	/// Convenience modifier for asset nodes.
	mutating public func withAsset(modifier: (inout AssetNode) -> Void) {
		if case .asset(var node) = self {
			modifier(&node)
			self = .asset(node)
		}
	}
	/// Convenience modifier for menu nodes.
	mutating public func withMenu(modifier: (inout MenuNode) -> Void) {
		if case .menu(var node) = self {
			modifier(&node)
			self = .menu(node)
		}
	}
	/// Convenience modifier for link nodes.
	mutating public func withLink(modifier: (inout LinkNode) -> Void) {
		if case .link(var node) = self {
			modifier(&node)
			self = .link(node)
		}
	}
	/// Convenience modifier for collection nodes.
	mutating public func withCollection(modifier: (inout CollectionNode) -> Void) {
		if case .collection(var node) = self {
			modifier(&node)
			self = .collection(node)
		}
	}
	/// Convenience modifier for opaque nodes.
	mutating public func withOpaque(modifier: (inout OpaqueNode) -> Void) {
		if case .opaque(var node) = self {
			modifier(&node)
			self = .opaque(node)
		}
	}

	/// Modify all media tree nodes matching a predicate.
	mutating public func modifyAll(where predicate: (MediaTree) -> Bool,
	                               modifier: (inout MediaTree) -> Void) {
		if predicate(self) { modifier(&self) }
		for index in childTrees.indices {
			childTrees[index].modifyAll(where: predicate, modifier: modifier)
		}
	}
	/// Modify the first media tree node matching a predicate.
	mutating public func modifyFirst(where predicate: (MediaTree) -> Bool,
	                                 modifier: (inout MediaTree) -> Void) {
		var found = false
		modifyAll(where: { !found && predicate($0) }) {
			modifier(&$0)
			found = true
		}
	}

	/// The list of immediate child trees of the current node.
	var childTrees: [Self] {
		get {
			switch self {
			case .asset(let assetNode):
				return assetNode.successor.map { [$0] } ?? []
			case .menu(let menuNode):
				return menuNode.children
			case .link:
				return []
			case .collection(let collectionNode):
				return collectionNode.children
			case .opaque(let opaqueNode):
				return opaqueNode.children
			}
		}
		set {
			switch self {
			case .asset(var assetNode):
				assert(newValue.count <= 1)
				assetNode.successor = newValue.first
				self = .asset(assetNode)
			case .menu(var menuNode):
				menuNode.children = newValue
				self = .menu(menuNode)
			case .link:
				return
			case .collection(var collectionNode):
				collectionNode.children = newValue
				self = .collection(collectionNode)
			case .opaque(var opaqueNode):
				opaqueNode.children = newValue
				self = .opaque(opaqueNode)
			}
		}
	}
}

extension MediaTree: Sequence {
	public func makeIterator() -> Iterator { Iterator(mediaTree: self) }

	/// Depth-first iterator over the media tree nodes.
	///
	/// Adds `Sequence` conformance to `MediaTree`.
	public struct Iterator: IteratorProtocol {
		var childIterators: [Array<MediaTree>.Iterator]

		init(mediaTree: MediaTree) {
			childIterators = [[mediaTree].makeIterator()]
		}

		mutating public func next() -> MediaTree? {
			while !childIterators.isEmpty {
				if let result = childIterators.last?.next() {
					childIterators.append(result.childTrees.makeIterator())
					return result
				} else {
					childIterators.removeLast()
				}
			}
			return nil
		}
	}

	/// The number of nodes in the media tree.
	public var count: Int { self.reduce(0) { result, _ in result + 1 } }
}

private extension Array {
	/// Last array element for usage in mutating optional chains.
	var last: Element? {
		get { return self.endIndex > 0 ? self[self.endIndex - 1] : nil }
		set {
			if let newValue = newValue {
				self[self.endIndex - 1] = newValue
			} else {
				self.removeLast()
			}
		}
	}
}
